#FactoryPattern(工厂模式)
##模式引入由来
一般而言，在创建一个对象时，Java要求使用new关键字以及这个类本身。而一旦这个对象被
创建出来，那么就可以灵活使用这个对象的抽象类型来引用它。因此，Java语言中创建一个对
象的过程是违背“开-闭”原则以及依赖倒转原则的。虽然在这个类被创建出来以后，可以通过多
态性使得客户端依赖于抽象类型。这是这个原因，设计模式给出了工厂模式，用于解决对象创建
过程中的依赖倒转问题。

##涉及的设计原则
**依赖倒置原则——要依赖抽象,不要依赖具体类。**（尽量达到，而不是随时遵循）
1. 变量中不持有具体类的引用;
2. 不要让子类了派生自具体类;
3. 不要覆盖基类中已实现的方法。


##模式定义
简单工厂——又称为静态工厂方法(Static Factory Method)模式,可以根据参数的不同返回不
同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例,不适用于继承。
工厂方法——工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，
这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该
实例化哪一个具体产品类。选择的条件是是否需要多个构建类。

###简单工厂
![image](https://github.com/SilenceDut/DesignPatterns/blob/master/pictures/FactoryUML/simple_factory_uml.png)

###工厂方法
![image](https://github.com/SilenceDut/DesignPatterns/blob/master/pictures/FactoryUML/factory_method_uml.png)

##优缺点
工厂模式的优点

- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于
一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一
定程度上提高了系统的灵活性。
- 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供
的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和
具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。

工厂模式的缺点

- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
-  在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中
类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系
统带来一些额外的开销。


##使用场景
- 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，
只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产
品的工厂类。
- 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个
创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，
在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 可以通过反射来减少工厂子类的数目。

##Demo
[**静态工厂模式Demo**](https://github.com/SilenceDut/DesignPatterns/blob/master/src/com/silencedut/creational_patterns/factory/simple_factory)

[**工厂方法模式Demo**](https://github.com/SilenceDut/DesignPatterns/blob/master/src/com/silencedut/creational_patterns/factory/factory_method)

[**反射工厂模式Demo**](https://github.com/SilenceDut/DesignPatterns/blob/master/src/com/silencedut/creational_patterns/factory)