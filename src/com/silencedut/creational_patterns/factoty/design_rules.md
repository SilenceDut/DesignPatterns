#FactoryPattern(工厂模式)
##模式引入由来
一般而言，在创建一个对象时，Java要求使用new关键字以及这个类本身。而一旦这个对象被
创建出来，那么就可以灵活使用这个对象的抽象类型来引用它。因此，Java语言中创建一个对
象的过程是违背“开-闭”原则以及依赖倒转原则的。虽然在这个类被创建出来以后，可以通过多
态性使得客户端依赖于抽象类型。这是这个原因，设计模式给出了工厂模式，用于解决对象创建
过程中的依赖倒转问题。

##涉及的设计原则
**依赖倒置原则——要依赖抽象,不要依赖具体类。**（尽量达到，而不是随时遵循）
1. 变量中不持有具体类的引用;
2. 不要让子类了派生自具体类;
3. 不要覆盖基类中已实现的方法。


##模式定义
简单工厂——又称为静态工厂方法(Static Factory Method)模式,可以根据参数的不同返回不
同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例,不适用于继承。
工厂方法——工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，
这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该
实例化哪一个具体产品类。
选择的条件是是否需要多个构建类。

###简单工厂
![image](https://github.com/SilenceDut/DesignPatterns/blob/master/pictures/FactoryUML/simple_factory_uml.png)

###工厂方法
![image](https://github.com/SilenceDut/DesignPatterns/blob/master/pictures/FactoryUML/factory_method_uml.png)

##优缺点
工厂模式的优点

- 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
- 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，
从而实现不同的行为。
- 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使
用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
- 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使
用时再对其进行组合，原有代码无须改变，符合“开闭原则”。

策略模式的缺点

- 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，
而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系
统的复杂度，加大学习与理解的难度。
- 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装
饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。
- 当针对特殊种类做一些特殊的事情,即针对特殊组件具体编程时,此模式将带来问题。

##使用场景
- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有
两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增
长；第二类是因为类定义不能继承（如final类）.
- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

##Demo
[**模式Demo**](https://github.com/SilenceDut/DesignPatterns/blob/master/src/com/silencedut/behavioral_patterns/ObserverPattern)
